import pefile
import hashlib
import numpy as np
from sklearn.ensemble import RandomForestClassifier
import joblib
from capstone import *
from capstone.x86 import *
import lief
from datetime import datetime

class AdvancedMalwareAnalyzer:
    def __init__(self):
        self.features = {}
        self.model = self.load_malware_model()
    
    def load_malware_model(self):
        """Carga el modelo de detección de malware"""
        try:
            return joblib.load('models/trained_models/malware_detector.pkl')
        except:
            print("[-] Modelo de malware no encontrado, creando uno básico")
            return RandomForestClassifier(n_estimators=100)
    
    def analyze_pe_file(self, file_path: str) -> dict:
        """Analiza archivos PE/EXE avanzado"""
        try:
            pe = pefile.PE(file_path)
            analysis = {}
            
            # Características estructurales
            analysis['file_size'] = self.get_file_size(file_path)
            analysis['entropy'] = self.calculate_entropy(file_path)
            analysis['md5_hash'] = self.calculate_hash(file_path, 'md5')
            analysis['sha256_hash'] = self.calculate_hash(file_path, 'sha256')
            
            # Características del header PE
            analysis['timestamp'] = pe.FILE_HEADER.TimeDateStamp
            analysis['sections'] = len(pe.sections)
            analysis['imports'] = len(pe.DIRECTORY_ENTRY_IMPORT) if hasattr(pe, 'DIRECTORY_ENTRY_IMPORT') else 0
            analysis['exports'] = len(pe.DIRECTORY_ENTRY_EXPORT) if hasattr(pe, 'DIRECTORY_ENTRY_EXPORT') else 0
            
            # Análisis de secciones sospechosas
            analysis['suspicious_sections'] = self.analyze_sections(pe)
            analysis['packer_indications'] = self.detect_packer(pe)
            analysis['anti_debug'] = self.check_anti_debug(pe)
            
            # Análisis de API imports
            analysis['suspicious_imports'] = self.analyze_imports(pe)
            analysis['network_apis'] = self.detect_network_apis(pe)
            
            return analysis
            
        except Exception as e:
            return {'error': str(e)}
    
    def analyze_sections(self, pe) -> list:
        """Analiza secciones del ejecutable"""
        suspicious_sections = []
        common_sections = ['.text', '.data', '.rdata', '.rsrc']
        
        for section in pe.sections:
            section_name = section.Name.decode('utf-8', errors='ignore').strip('\x00')
            section_entropy = self.calculate_section_entropy(section)
            
            # Detectar secciones sospechosas
            if (section_name not in common_sections or 
                section_entropy > 7.0 or  # Alta entropía indica posible packing
                section.Misc_VirtualSize > section.SizeOfRawData * 2):
                
                suspicious_sections.append({
                    'name': section_name,
                    'entropy': section_entropy,
                    'virtual_size': section.Misc_VirtualSize,
                    'raw_size': section.SizeOfRawData
                })
        
        return suspicious_sections
    
    def analyze_imports(self, pe) -> list:
        """Analiza imports de APIs sospechosas"""
        suspicious_apis = [
            'VirtualAlloc', 'VirtualProtect', 'CreateRemoteThread',
            'WriteProcessMemory', 'SetWindowsHook', 'GetAsyncKeyState',
            'URLDownloadToFile', 'ShellExecute', 'WinExec'
        ]
        
        found_apis = []
        if hasattr(pe, 'DIRECTORY_ENTRY_IMPORT'):
            for entry in pe.DIRECTORY_ENTRY_IMPORT:
                for imp in entry.imports:
                    if imp.name:
                        api_name = imp.name.decode('utf-8', errors='ignore')
                        if any(suspicious in api_name for suspicious in suspicious_apis):
                            found_apis.append(api_name)
        
        return found_apis
    
    def extract_malware_features(self, analysis: dict) -> np.array:
        """Extrae características para el modelo ML"""
        features = []
        
        # Características numéricas
        features.append(analysis.get('file_size', 0))
        features.append(analysis.get('entropy', 0))
        features.append(analysis.get('sections', 0))
        features.append(analysis.get('imports', 0))
        features.append(len(analysis.get('suspicious_sections', [])))
        features.append(len(analysis.get('suspicious_imports', [])))
        
        # Características binarias
        features.append(1 if analysis.get('packer_indications', False) else 0)
        features.append(1 if analysis.get('anti_debug', False) else 0)
        features.append(1 if analysis.get('network_apis', False) else 0)
        
        return np.array(features).reshape(1, -1)
    
    def predict_malware(self, file_path: str) -> dict:
        """Predice si un archivo es malware"""
        analysis = self.analyze_pe_file(file_path)
        
        if 'error' in analysis:
            return {'error': analysis['error']}
        
        features = self.extract_malware_features(analysis)
        probability = self.model.predict_proba(features)[0, 1]
        
        return {
            'is_malware': probability > 0.7,
            'probability': probability,
            'analysis': analysis,
            'verdict': 'MALWARE' if probability > 0.7 else 'CLEAN'
        }